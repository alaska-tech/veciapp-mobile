# üîî Sistema de Notificaciones - Veciapp Mobile

Este documento explica **COMPLETAMENTE** c√≥mo usar el sistema de notificaciones implementado en la aplicaci√≥n Veciapp Mobile, incluyendo **notificaciones locales** y **push desde el backend**.

## üìã Funcionalidades Disponibles

### 1. **Notificaciones Push (Desde Backend)**
- ‚úÖ Registro autom√°tico del dispositivo
- ‚úÖ Recepci√≥n de notificaciones del servidor
- ‚úÖ Manejo de notificaciones en primer y segundo plano
- ‚úÖ Navegaci√≥n autom√°tica al tocar notificaciones
- ‚úÖ Tokens √∫nicos por dispositivo

### 2. **Notificaciones Locales (Desde la App)**
- ‚úÖ Env√≠o inmediato de notificaciones
- ‚úÖ Programaci√≥n de notificaciones para fechas espec√≠ficas
- ‚úÖ Notificaciones recurrentes (diarias, semanales, etc.)
- ‚úÖ Notificaciones con delays personalizados

### 3. **Gesti√≥n de Notificaciones**
- ‚úÖ Cancelar notificaciones espec√≠ficas
- ‚úÖ Cancelar todas las notificaciones
- ‚úÖ Ver notificaciones programadas
- ‚úÖ Configurar y limpiar badges (n√∫meros en el √≠cono)

## üöÄ IMPLEMENTACI√ìN COMPLETA

### **PASO 1: Configuraci√≥n Inicial**

#### 1.1 Verificar Dependencias
Aseg√∫rate de que estas dependencias est√©n en tu `package.json`:
```json
{
  "dependencies": {
    "expo-notifications": "^0.31.4",
    "expo-device": "^7.1.4"
  }
}
```

#### 1.2 Configuraci√≥n del app.json
Tu `app.json` ya debe tener esta configuraci√≥n:
```json
{
  "expo": {
    "plugins": [
      [
        "expo-notifications",
        {
          "icon": "./assets/images/notification-icon.png",
          "color": "#ffffff",
          "sounds": ["./assets/sounds/notification.wav"]
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "be5bed90-b3e3-4c8b-95d4-e5595057a604"
      }
    }
  }
}
```

### **PASO 2: Configuraci√≥n en el Componente Principal**

#### 2.1 Importar Funciones
```typescript
import {
  registerForPushNotifications,
  sendImmediateNotification,
  scheduleLocalNotification,
  cancelNotification,
  cancelAllNotifications,
  getScheduledNotifications,
  setBadgeCount,
  clearBadge,
  addNotificationReceivedListener,
  addNotificationResponseReceivedListener,
} from '~/lib/notifications';
```

#### 2.2 Configurar Notificaciones al Iniciar la App
```typescript
// En tu App.tsx o componente principal
useEffect(() => {
  setupNotifications();
}, []);

const setupNotifications = async () => {
  try {
    // 1. Registrar para notificaciones push
    const token = await registerForPushNotifications();
    if (token) {
      console.log('‚úÖ Dispositivo registrado para notificaciones push');
      console.log('üîë Token:', token.data);
      
      // 2. ENVIAR ESTE TOKEN A TU BACKEND
      await sendTokenToBackend(token.data);
    }

    // 3. Configurar listeners para notificaciones
    setupNotificationListeners();
  } catch (error) {
    console.error('‚ùå Error al configurar notificaciones:', error);
  }
};
```

#### 2.3 Configurar Listeners
```typescript
const setupNotificationListeners = () => {
  // Listener para notificaciones recibidas en primer plano
  const receivedSubscription = addNotificationReceivedListener(notification => {
    console.log('üì± Notificaci√≥n recibida en primer plano:', notification);
    
    // Aqu√≠ puedes mostrar un toast o alert personalizado
    showCustomNotification(notification);
  });

  // Listener para cuando el usuario TOCA la notificaci√≥n
  const responseSubscription = addNotificationResponseReceivedListener(response => {
    console.log('üëÜ Usuario toc√≥ la notificaci√≥n:', response);
    
    // Extraer datos de la notificaci√≥n
    const data = response.notification.request.content.data;
    
    // Navegar a la pantalla correspondiente
    if (data?.screen) {
      router.push(data.screen);
    }
    
    // Limpiar badge si es necesario
    if (data?.clearBadge) {
      clearBadge();
    }
  });

  // Cleanup al desmontar
  return () => {
    receivedSubscription.remove();
    responseSubscription.remove();
  };
};
```

#### 2.4 Enviar Token al Backend
```typescript
const sendTokenToBackend = async (token: string) => {
  try {
    const response = await fetch(`${process.env.EXPO_PUBLIC_BACKEND_URL}/api/notifications/register-device`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${userToken}`, // Token del usuario logueado
      },
      body: JSON.stringify({
        deviceToken: token,
        platform: Platform.OS, // 'ios' o 'android'
        userId: currentUser.id,
        appVersion: Constants.expoConfig?.version || '1.0.0',
      }),
    });

    if (response.ok) {
      console.log('‚úÖ Token enviado al backend exitosamente');
    } else {
      console.error('‚ùå Error al enviar token al backend');
    }
  } catch (error) {
    console.error('‚ùå Error de red al enviar token:', error);
  }
};
```

## üîî NOTIFICACIONES LOCALES (DESDE LA APP)

### **Env√≠o Inmediato**
```typescript
const handleSendNotification = async () => {
  try {
    const notificationId = await sendImmediateNotification(
      '¬°Nuevo Pedido! üéâ',
      'Tu pedido #12345 ha sido confirmado',
      { 
        screen: '/orders/12345',
        orderId: '12345',
        type: 'order_confirmation'
      }
    );
    
    if (notificationId) {
      console.log('‚úÖ Notificaci√≥n enviada con ID:', notificationId);
    }
  } catch (error) {
    console.error('‚ùå Error al enviar notificaci√≥n:', error);
  }
};
```

### **Programar Notificaci√≥n con Delay**
```typescript
// Notificaci√≥n en 30 segundos
const scheduleReminder = async () => {
  const notificationId = await scheduleLocalNotification(
    'Recordatorio ‚è∞',
    'Tu pedido llegar√° en 30 minutos',
    { screen: '/orders', type: 'delivery_reminder' },
    { 
      type: 'timeInterval',
      seconds: 30 
    }
  );
  
  console.log('‚è∞ Notificaci√≥n programada para 30 segundos');
  return notificationId;
};
```

### **Programar Notificaci√≥n Diaria**
```typescript
const scheduleDailyReminder = async () => {
  const notificationId = await scheduleLocalNotification(
    'Revisa tus Pedidos üìã',
    'No olvides revisar el estado de tus pedidos diariamente',
    { screen: '/orders', type: 'daily_reminder' },
    {
      type: 'calendar',
      hour: 18, // 6:00 PM
      minute: 0,
      repeats: true, // Se repite todos los d√≠as
    }
  );
  
  console.log('üìÖ Notificaci√≥n diaria programada para las 6:00 PM');
  return notificationId;
};
```

### **Programar Notificaci√≥n Semanal**
```typescript
const scheduleWeeklyReport = async () => {
  const notificationId = await scheduleLocalNotification(
    'Reporte Semanal üìä',
    'Revisa tu resumen semanal de pedidos',
    { screen: '/reports', type: 'weekly_report' },
    {
      type: 'calendar',
      weekday: 1, // Lunes (1 = Lunes, 2 = Martes, etc.)
      hour: 9,
      minute: 0,
      repeats: true,
    }
  );
  
  console.log('üìä Notificaci√≥n semanal programada para los lunes a las 9:00 AM');
  return notificationId;
};
```

### **Programar Notificaci√≥n en Fecha Espec√≠fica**
```typescript
const scheduleSpecialEvent = async () => {
  const eventDate = new Date('2024-12-25T10:00:00');
  
  const notificationId = await scheduleLocalNotification(
    '¬°Evento Especial! üéÑ',
    'Hoy tienes descuentos especiales de Navidad',
    { screen: '/promotions', type: 'christmas_sale' },
    {
      type: 'date',
      date: eventDate,
    }
  );
  
  console.log('üéÑ Notificaci√≥n programada para Navidad');
  return notificationId;
};
```

## üåê NOTIFICACIONES PUSH (DESDE BACKEND)

### **PASO 3: Configuraci√≥n del Backend**

#### 3.1 Endpoint para Registrar Dispositivos
```javascript
// POST /api/notifications/register-device
app.post('/api/notifications/register-device', async (req, res) => {
  try {
    const { deviceToken, platform, userId, appVersion } = req.body;
    
    // Guardar en tu base de datos
    await DeviceToken.create({
      token: deviceToken,
      platform,
      userId,
      appVersion,
      isActive: true,
      createdAt: new Date()
    });
    
    res.json({ success: true, message: 'Dispositivo registrado' });
  } catch (error) {
    res.status(500).json({ error: 'Error al registrar dispositivo' });
  }
});
```

#### 3.2 Funci√≥n para Enviar Notificaciones Push
```javascript
// Funci√≥n para enviar notificaci√≥n push a un usuario espec√≠fico
async function sendPushNotification(userId, notification) {
  try {
    // Obtener todos los tokens del usuario
    const deviceTokens = await DeviceToken.findAll({
      where: { userId, isActive: true }
    });
    
    if (deviceTokens.length === 0) {
      console.log(`No hay dispositivos registrados para el usuario ${userId}`);
      return;
    }
    
    // Enviar a cada dispositivo del usuario
    const promises = deviceTokens.map(async (deviceToken) => {
      try {
        const response = await fetch('https://exp.host/--/api/v2/push/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Accept-encoding': 'gzip, deflate',
          },
          body: JSON.stringify({
            to: deviceToken.token,
            title: notification.title,
            body: notification.body,
            data: notification.data || {},
            sound: 'default',
            badge: notification.badge || 1,
            channelId: 'default',
            priority: 'high',
          }),
        });
        
        const result = await response.json();
        
        if (result.errors) {
          console.error('Error al enviar notificaci√≥n:', result.errors);
          // Marcar token como inactivo si hay error
          if (result.errors[0]?.code === 'DeviceNotRegistered') {
            await deviceToken.update({ isActive: false });
          }
        } else {
          console.log('‚úÖ Notificaci√≥n enviada exitosamente');
        }
      } catch (error) {
        console.error('Error al enviar notificaci√≥n:', error);
      }
    });
    
    await Promise.all(promises);
  } catch (error) {
    console.error('Error general al enviar notificaciones:', error);
  }
}
```

#### 3.3 Endpoint para Enviar Notificaciones
```javascript
// POST /api/notifications/send
app.post('/api/notifications/send', async (req, res) => {
  try {
    const { userId, title, body, data, badge } = req.body;
    
    // Validar datos
    if (!userId || !title || !body) {
      return res.status(400).json({ error: 'Faltan datos requeridos' });
    }
    
    // Enviar notificaci√≥n
    await sendPushNotification(userId, {
      title,
      body,
      data,
      badge
    });
    
    res.json({ success: true, message: 'Notificaci√≥n enviada' });
  } catch (error) {
    res.status(500).json({ error: 'Error al enviar notificaci√≥n' });
  }
});
```

#### 3.4 Env√≠o Masivo de Notificaciones
```javascript
// POST /api/notifications/send-bulk
app.post('/api/notifications/send-bulk', async (req, res) => {
  try {
    const { userIds, title, body, data, badge } = req.body;
    
    // Enviar a m√∫ltiples usuarios
    const promises = userIds.map(userId => 
      sendPushNotification(userId, { title, body, data, badge })
    );
    
    await Promise.all(promises);
    
    res.json({ success: true, message: `Notificaciones enviadas a ${userIds.length} usuarios` });
  } catch (error) {
    res.status(500).json({ error: 'Error al enviar notificaciones masivas' });
  }
});
```

### **PASO 4: Casos de Uso del Backend**

#### 4.1 Notificaci√≥n de Nuevo Pedido
```javascript
// Cuando se crea un nuevo pedido
app.post('/api/orders', async (req, res) => {
  try {
    const order = await Order.create(req.body);
    
    // Enviar notificaci√≥n al cliente
    await sendPushNotification(order.userId, {
      title: '¬°Nuevo Pedido Confirmado! üéâ',
      body: `Tu pedido #${order.id} ha sido confirmado y est√° siendo procesado`,
      data: {
        screen: '/orders',
        orderId: order.id,
        type: 'order_confirmed'
      },
      badge: 1
    });
    
    res.json({ success: true, order });
  } catch (error) {
    res.status(500).json({ error: 'Error al crear pedido' });
  }
});
```

#### 4.2 Notificaci√≥n de Cambio de Estado
```javascript
// Cuando cambia el estado de un pedido
app.put('/api/orders/:id/status', async (req, res) => {
  try {
    const { status } = req.body;
    const order = await Order.findByPk(req.params.id);
    
    await order.update({ status });
    
    // Mapear estados a mensajes
    const statusMessages = {
      'preparing': 'Tu pedido est√° siendo preparado üë®‚Äçüç≥',
      'ready': '¬°Tu pedido est√° listo para recoger! üöÄ',
      'delivering': 'Tu pedido est√° en camino üöö',
      'delivered': '¬°Tu pedido ha sido entregado! ‚úÖ'
    };
    
    // Enviar notificaci√≥n
    await sendPushNotification(order.userId, {
      title: 'Actualizaci√≥n de Pedido üì¶',
      body: statusMessages[status] || `Estado actualizado: ${status}`,
      data: {
        screen: '/orders',
        orderId: order.id,
        type: 'status_update',
        newStatus: status
      },
      badge: 1
    });
    
    res.json({ success: true, order });
  } catch (error) {
    res.status(500).json({ error: 'Error al actualizar estado' });
  }
});
```

#### 4.3 Notificaci√≥n de Chat
```javascript
// Cuando llega un nuevo mensaje
app.post('/api/chat/messages', async (req, res) => {
  try {
    const message = await ChatMessage.create(req.body);
    
    // Obtener informaci√≥n del chat
    const chat = await Chat.findByPk(message.chatId, {
      include: [{ model: User, as: 'participants' }]
    });
    
    // Enviar notificaci√≥n a todos los participantes excepto al remitente
    const recipients = chat.participants.filter(p => p.id !== message.senderId);
    
    const promises = recipients.map(recipient =>
      sendPushNotification(recipient.id, {
        title: 'Nuevo Mensaje üí¨',
        body: `${message.senderName}: ${message.content.substring(0, 50)}...`,
        data: {
          screen: '/chats',
          chatId: chat.id,
          type: 'new_message',
          senderId: message.senderId
        },
        badge: 1
      })
    );
    
    await Promise.all(promises);
    
    res.json({ success: true, message });
  } catch (error) {
    res.status(500).json({ error: 'Error al enviar mensaje' });
  }
});
```

#### 4.4 Notificaci√≥n de Promoci√≥n
```javascript
// Env√≠o masivo de promociones
app.post('/api/promotions/send', async (req, res) => {
  try {
    const { title, body, data, targetUsers } = req.body;
    
    // Obtener usuarios objetivo (por ejemplo, usuarios activos en los √∫ltimos 30 d√≠as)
    let userIds;
    if (targetUsers === 'active') {
      const activeUsers = await User.findAll({
        where: {
          lastLoginAt: {
            [Op.gte]: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
          }
        },
        attributes: ['id']
      });
      userIds = activeUsers.map(u => u.id);
    } else if (targetUsers === 'all') {
      const allUsers = await User.findAll({ attributes: ['id'] });
      userIds = allUsers.map(u => u.id);
    } else {
      userIds = targetUsers; // Array de IDs espec√≠ficos
    }
    
    // Enviar notificaciones
    await sendPushNotification(userIds, {
      title,
      body,
      data: {
        screen: '/promotions',
        type: 'promotion',
        ...data
      },
      badge: 1
    });
    
    res.json({ success: true, message: `Promoci√≥n enviada a ${userIds.length} usuarios` });
  } catch (error) {
    res.status(500).json({ error: 'Error al enviar promoci√≥n' });
  }
});
```

## üéØ CASOS DE USO ESPEC√çFICOS PARA VECIAPP

### **1. Notificaciones de Pedidos**
```typescript
// Cliente: Pedido confirmado
await sendImmediateNotification(
  '¬°Pedido Confirmado! üéâ',
  'Tu pedido #12345 ha sido confirmado y est√° siendo procesado',
  { screen: '/orders/12345', orderId: '12345' }
);

// Cliente: Pedido en preparaci√≥n
await scheduleLocalNotification(
  'Tu Pedido se Est√° Preparando üë®‚Äçüç≥',
  'El vendedor est√° preparando tu pedido. Estar√° listo pronto.',
  { screen: '/orders/12345', orderId: '12345' },
  { type: 'timeInterval', seconds: 300 } // 5 minutos
);

// Cliente: Pedido listo
await sendImmediateNotification(
  '¬°Tu Pedido Est√° Listo! üöÄ',
  'Puedes pasar a recoger tu pedido #12345',
  { screen: '/orders/12345', orderId: '12345' }
);
```

### **2. Notificaciones de Chat**
```typescript
// Nuevo mensaje del vendedor
await sendImmediateNotification(
  'Nuevo Mensaje del Vendedor üí¨',
  'Tienes un nuevo mensaje sobre tu pedido',
  { screen: '/chats', chatId: 'chat123' }
);

// Recordatorio de chat inactivo
await scheduleLocalNotification(
  '¬øTienes Dudas? üí≠',
  'No dudes en preguntar si tienes alguna duda sobre tu pedido',
  { screen: '/chats', chatId: 'chat123' },
  { type: 'timeInterval', seconds: 3600 } // 1 hora
);
```

### **3. Notificaciones de Ubicaci√≥n**
```typescript
// Pedido cerca de la ubicaci√≥n
await sendImmediateNotification(
  '¬°Tu Pedido Est√° Cerca! üìç',
  'Tu pedido est√° a 5 minutos de tu ubicaci√≥n',
  { screen: '/orders/12345', orderId: '12345' }
);

// Recordatorio de ubicaci√≥n
await scheduleLocalNotification(
  'Actualiza tu Ubicaci√≥n üìç',
  'Aseg√∫rate de que tu ubicaci√≥n est√© actualizada para recibir tu pedido',
  { screen: '/profile/location' },
  { type: 'calendar', hour: 12, minute: 0, repeats: true } // Diario a las 12 PM
);
```

### **4. Notificaciones de Promociones**
```typescript
// Oferta especial
await scheduleLocalNotification(
  '¬°Oferta Especial! üéÅ',
  'Hoy tienes 20% de descuento en todos los productos',
  { screen: '/promotions', type: 'special_offer' },
  { type: 'calendar', hour: 9, minute: 0, repeats: false } // Solo hoy a las 9 AM
);

// Recordatorio de carrito abandonado
await scheduleLocalNotification(
  '¬°No Olvides tu Carrito! üõí',
  'Tienes productos en tu carrito esperando por ti',
  { screen: '/cart', type: 'abandoned_cart' },
  { type: 'timeInterval', seconds: 7200 } // 2 horas
);
```

## üîß GESTI√ìN AVANZADA DE NOTIFICACIONES

### **Cancelar Notificaciones Espec√≠ficas**
```typescript
// Cancelar notificaci√≥n de recordatorio de pedido
const cancelOrderReminder = async (orderId: string) => {
  try {
    // Obtener todas las notificaciones programadas
    const notifications = await getScheduledNotifications();
    
    // Encontrar la notificaci√≥n espec√≠fica
    const targetNotification = notifications.find(n => 
      n.content.data?.orderId === orderId && 
      n.content.data?.type === 'order_reminder'
    );
    
    if (targetNotification) {
      await cancelNotification(targetNotification.identifier);
      console.log('‚úÖ Recordatorio de pedido cancelado');
    }
  } catch (error) {
    console.error('‚ùå Error al cancelar recordatorio:', error);
  }
};
```

### **Gestionar Badges Inteligentemente**
```typescript
// Configurar badge basado en notificaciones no le√≠das
const updateBadgeCount = async () => {
  try {
    // Obtener notificaciones no le√≠das del backend
    const response = await fetch(`${process.env.EXPO_PUBLIC_BACKEND_URL}/api/notifications/unread-count`);
    const { count } = await response.json();
    
    // Actualizar badge
    await setBadgeCount(count);
    console.log(`üî¢ Badge actualizado a ${count}`);
  } catch (error) {
    console.error('‚ùå Error al actualizar badge:', error);
  }
};

// Limpiar badge al abrir la app
const clearBadgeOnAppOpen = async () => {
  try {
    await clearBadge();
    console.log('üßπ Badge limpiado al abrir la app');
  } catch (error) {
    console.error('‚ùå Error al limpiar badge:', error);
  }
};
```

### **Notificaciones con Sonidos Personalizados**
```typescript
// Notificaci√≥n con sonido personalizado (solo Android)
const sendNotificationWithCustomSound = async () => {
  try {
    const notificationId = await scheduleLocalNotification(
      'Notificaci√≥n con Sonido üéµ',
      'Esta notificaci√≥n tiene un sonido personalizado',
      { screen: '/home', type: 'custom_sound' },
      null, // Sin trigger = inmediata
      {
        sound: 'custom_sound.wav', // Archivo de sonido personalizado
        priority: 'high'
      }
    );
    
    console.log('üéµ Notificaci√≥n con sonido personalizado enviada');
    return notificationId;
  } catch (error) {
    console.error('‚ùå Error al enviar notificaci√≥n con sonido:', error);
  }
};
```

## üì± CONFIGURACI√ìN POR PLATAFORMA

### **iOS**
```typescript
// Configuraci√≥n espec√≠fica para iOS
if (Platform.OS === 'ios') {
  // Solicitar permisos espec√≠ficos
  const { status } = await Notifications.requestPermissionsAsync({
    ios: {
      allowAlert: true,
      allowBadge: true,
      allowSound: true,
      allowAnnouncements: true,
    },
  });
  
  if (status === 'granted') {
    console.log('‚úÖ Permisos de iOS concedidos');
  }
}
```

### **Android**
```typescript
// Configuraci√≥n espec√≠fica para Android
if (Platform.OS === 'android') {
  // Crear canal de notificaciones personalizado
  await Notifications.setNotificationChannelAsync('orders', {
    name: 'Pedidos',
    importance: Notifications.AndroidImportance.HIGH,
    vibrationPattern: [0, 250, 250, 250],
    lightColor: '#FF231F7C',
    sound: 'default',
    enableVibrate: true,
    showBadge: true,
  });
  
  // Crear canal para promociones
  await Notifications.setNotificationChannelAsync('promotions', {
    name: 'Promociones',
    importance: Notifications.AndroidImportance.DEFAULT,
    vibrationPattern: [0, 100, 100, 100],
    lightColor: '#4CAF50',
    sound: 'default',
    enableVibrate: true,
    showBadge: false,
  });
}
```

## üß™ PRUEBAS Y DEBUGGING

### **Funci√≥n de Prueba Completa**
```typescript
const testAllNotifications = async () => {
  try {
    console.log('üß™ Iniciando pruebas de notificaciones...');
    
    // 1. Notificaci√≥n inmediata
    console.log('üì± Enviando notificaci√≥n inmediata...');
    await sendImmediateNotification(
      'Prueba Inmediata ‚ö°',
      'Esta es una notificaci√≥n de prueba inmediata',
      { screen: '/test', type: 'immediate_test' }
    );
    
    // 2. Notificaci√≥n programada
    console.log('‚è∞ Programando notificaci√≥n para 10 segundos...');
    const scheduledId = await scheduleLocalNotification(
      'Prueba Programada ‚è∞',
      'Esta notificaci√≥n se program√≥ para 10 segundos',
      { screen: '/test', type: 'scheduled_test' },
      { type: 'timeInterval', seconds: 10 }
    );
    
    // 3. Configurar badge
    console.log('üî¢ Configurando badge a 3...');
    await setBadgeCount(3);
    
    // 4. Ver notificaciones programadas
    console.log('üìã Obteniendo notificaciones programadas...');
    const scheduled = await getScheduledNotifications();
    console.log(`üìã Tienes ${scheduled.length} notificaci√≥n(es) programada(s)`);
    
    // 5. Limpiar badge despu√©s de 15 segundos
    setTimeout(async () => {
      console.log('üßπ Limpiando badge...');
      await clearBadge();
      console.log('‚úÖ Badge limpiado');
    }, 15000);
    
    console.log('‚úÖ Todas las pruebas completadas');
    
  } catch (error) {
    console.error('‚ùå Error en las pruebas:', error);
  }
};
```

### **Logs de Debugging**
```typescript
// Agregar logs detallados para debugging
const debugNotification = async (action: string, data?: any) => {
  const timestamp = new Date().toISOString();
  console.log(`üîç [${timestamp}] ${action}:`, data);
  
  // Tambi√©n puedes enviar a un servicio de logging
  try {
    await fetch(`${process.env.EXPO_PUBLIC_BACKEND_URL}/api/logs`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        level: 'debug',
        action,
        data,
        timestamp,
        platform: Platform.OS,
        appVersion: Constants.expoConfig?.version
      })
    });
  } catch (error) {
    console.error('Error al enviar log:', error);
  }
};
```

## üö® SOLUCI√ìN DE PROBLEMAS

### **Problema: Notificaciones no aparecen**
```typescript
// Verificar configuraci√≥n paso a paso
const debugNotificationSetup = async () => {
  try {
    console.log('üîç Debugging configuraci√≥n de notificaciones...');
    
    // 1. Verificar permisos
    const permissions = await Notifications.getPermissionsAsync();
    console.log('üìã Permisos:', permissions);
    
    // 2. Verificar handler
    const handler = Notifications.getNotificationHandler();
    console.log('‚öôÔ∏è Handler configurado:', !!handler);
    
    // 3. Verificar si es dispositivo f√≠sico
    console.log('üì± Es dispositivo f√≠sico:', Device.isDevice);
    
    // 4. Verificar configuraci√≥n del proyecto
    console.log('üèóÔ∏è Project ID:', Constants.expoConfig?.extra?.eas?.projectId);
    
    // 5. Probar notificaci√≥n de prueba
    await sendImmediateNotification(
      'Prueba de Debug üîç',
      'Si ves esto, las notificaciones funcionan',
      { type: 'debug_test' }
    );
    
  } catch (error) {
    console.error('‚ùå Error en debugging:', error);
  }
};
```

### **Problema: Tokens no se generan**
```typescript
// Verificar generaci√≥n de tokens
const debugTokenGeneration = async () => {
  try {
    console.log('üîë Debugging generaci√≥n de tokens...');
    
    // 1. Verificar configuraci√≥n de EAS
    const projectId = Constants.expoConfig?.extra?.eas?.projectId;
    console.log('üèóÔ∏è Project ID encontrado:', projectId);
    
    if (!projectId) {
      console.error('‚ùå No se encontr√≥ Project ID en la configuraci√≥n');
      return;
    }
    
    // 2. Intentar generar token
    const token = await Notifications.getExpoPushTokenAsync({
      projectId: projectId
    });
    
    console.log('‚úÖ Token generado exitosamente:', token.data);
    return token;
    
  } catch (error) {
    console.error('‚ùå Error al generar token:', error);
    
    // Verificar si es un error de configuraci√≥n
    if (error.message?.includes('projectId')) {
      console.error('üí° Verifica que tengas un Project ID v√°lido en app.json');
    }
  }
};
```

## üìö RECURSOS ADICIONALES

### **Documentaci√≥n Oficial**
- [Expo Notifications](https://docs.expo.dev/versions/latest/sdk/notifications/)
- [Expo Push Notifications](https://docs.expo.dev/push-notifications/overview/)
- [EAS Build](https://docs.expo.dev/build/introduction/)

### **Herramientas de Testing**
- [Expo Push Tool](https://expo.dev/notifications) - Para probar notificaciones push
- [Expo Dev Tools](https://docs.expo.dev/develop/tools/) - Para debugging

### **Mejores Pr√°cticas**
- **No spamear**: Respeta los l√≠mites de notificaciones
- **Personalizaci√≥n**: Usa datos del usuario para personalizar mensajes
- **Timing**: Env√≠a notificaciones en momentos apropiados
- **Testing**: Prueba en dispositivos f√≠sicos antes de producci√≥n

---

## üéâ ¬°LISTO PARA PRODUCCI√ìN!

Con esta implementaci√≥n completa tienes:

‚úÖ **Notificaciones locales** funcionando perfectamente  
‚úÖ **Sistema de push** listo para conectar con tu backend  
‚úÖ **Gesti√≥n completa** de notificaciones y badges  
‚úÖ **Configuraci√≥n optimizada** para iOS y Android  
‚úÖ **Casos de uso espec√≠ficos** para Veciapp  
‚úÖ **Herramientas de debugging** para resolver problemas  
‚úÖ **Documentaci√≥n completa** para tu equipo  

**¬°Tu aplicaci√≥n est√° lista para mantener a los usuarios informados y comprometidos!** üöÄ

---

**¬øNecesitas ayuda con alg√∫n aspecto espec√≠fico o tienes preguntas sobre la implementaci√≥n?** ü§î
